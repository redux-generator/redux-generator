{"types":"<% Object.keys(worker).forEach(elem => { -%>\n// <%- worker[elem].comment %>\n<%  for (let item of worker[elem].element){ -%>\nexport const <%-item.type-%> = \"<%-item.typePrefix-%>/<%-item.type-%>\";\n<% } -%>\n<% }); -%>","actions":"import * as types from \"./types\";\n<% if(options.ts) { -%>\nimport * as model from \"./model\";\nimport { inferLiteral } from \"./model\";\n<% } -%>\n\n<% Object.keys(worker).forEach(elem => { -%>\n// <%- worker[elem].comment %>\n<% for (let item of worker[elem].element){ -%>\n<% if(options.ts) { -%>\nexport const <%-item.actionName-%> = (payload: model.<%-item.actionPayload-%>) => ({\n  type: inferLiteral(types.<%-item.type-%>),\n  payload\n} as const);\n<% } else { -%>\nexport const <%-item.actionName-%> = (payload) => ({\n  type: types.<%-item.type-%>,\n  payload\n});\n<% } -%>\n<% } %>\n<% }); -%>","model":"import { Action } from \"redux\";\nimport * as actions from \"./actions\";\n\n// general for redux\ntype inferValueType<T> = T extends { [key: string]: infer U } ? U : never;\nconst iL = <U, T extends U>(arg: T): T => arg;\nexport const inferLiteral = <T extends string>(arg: T): T => iL(arg);\nexport type <%-options.entityActionTypes-%> = ReturnType<inferValueType<typeof actions>>;\n<% Object.keys(worker).forEach(elem => { %>\n// <%- worker[elem].comment %>\n<% for (let item of worker[elem].element){ -%>\nexport type <%-item.actionPayload-%> = {};\n<% } -%>\n<% for (let item of worker[elem].element){ -%>\n<% if(item.actionType) { %>\nexport type <%-item.actionType-%> = (payload: <%-item.actionPayload-%>) => <%-options.entityActionTypes-%>;\nexport interface <%-item.sagaType-%> extends Action {\n  payload: <%-item.actionPayload-%>;\n}\n<% } -%>\n<% } -%>\n<% }); -%>\n// main type\nexport type <%-options.mainType-%> = {};","reducer":"import * as types from \"./types\";\n<% if(options.ts) { -%>\nimport { <%-options.entityActionTypes-%>, <%-options.mainType-%> } from \"./model\";\n\nconst initialState: <%-options.mainType-%> = {};\n<% } else { %>\nconst initialState = {};\n<% } -%>\n<% if(options.ts) { -%>\nexport const <%-options.singleEntityLowerCase-%>Reducer = (state = initialState, action: <%-options.entityActionTypes-%>): <%-options.mainType-%> => {\n<% } else { %>\nexport const <%-options.singleEntityLowerCase-%>Reducer = (state = initialState, action) => {\n<% } -%>\n  switch (action.type) {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n  case types.<%-item.type-%>: {\n    return { ...state };\n  }\n<% } %>\n<% }); -%>\n    default:\n      return state;\n  }\n};\n","saga":"import { call, takeEvery, put } from \"redux-saga/effects\";\n\nimport * as types from \"./types\";\nimport * as actions from \"./actions\";\nimport { <%-options.apiNameTitle-%> } from './api';\n<% if(options.ts) { -%>\nimport {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n<% if(item.sagaType) { -%>\n  <%-item.sagaType-%>,\n<% } -%>\n<% } -%>\n<% }); -%>\n} from \"./model\";\n<% } %>\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n<% if(item.sagaType) { -%>\n<% if(options.ts) { -%>\nfunction* <%-item.sagaFuncName-%>({ payload }: <%-item.sagaType-%>) {\n<% } else { -%>\nfunction* <%-item.sagaFuncName-%>({ payload }) {\n<% } -%>\n  try {\n    const response = yield call(<%-options.apiNameTitle-%>.<%-item.apiFuncName-%>);\n\n    yield put(actions.<%-item.sagaActions[0]-%>(response));\n  } catch (error) {\n    yield put(actions.<%-item.sagaActions[1]-%>(error));\n  }\n}\n<% } -%>\n<% } %>\n<% }); %>\nfunction* <%-options.singleEntityLowerCase-%>() {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n<% if(item.sagaFuncName) { -%>\n  yield takeEvery(types.<%-item.type-%>, <%-item.sagaFuncName-%>);\n<% } -%>\n<% } -%>\n<% }); -%>\n}\n\nexport default <%-options.singleEntityLowerCase-%>;","actions_test":"import * as actions from './actions';\nimport * as types from './types';\n\ndescribe('<%-options.singleEntityLowerCase-%> actions', () => {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n  it('should create an action - <%-item.actionName-%>', () => {\n    const payload = {};\n    const expectedAction = { type: types.<%-item.type-%>, payload };\n    expect(actions.<%-item.actionName-%>(payload)).toEqual(expectedAction);\n  });\n<% } %>\n<% }); -%>\n});\n","reducer_test":"import { <%-options.singleEntityLowerCase-%>Reducer } from './reducer';\nimport * as types from './types';\n<% if(options.ts) { -%>\nimport { inferLiteral } from \"./model\";\n<% } -%>\n\nconst initialStore = {};\n\ndescribe('<%-options.singleEntityLowerCase-%> reducer', () => {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n  it('should handle <%-item.type-%>', () => {\n    const action = {\n<% if(options.ts) { -%>\n      type: inferLiteral(types.<%-item.type-%>),\n<% } else { -%>\n      type: types.<%-item.type-%>,\n<% } -%>\n      payload: {},\n    };\n    expect(<%-options.singleEntityLowerCase-%>Reducer(initialStore, action)).toEqual({ ...initialStore });\n  });\n<% } %>\n<% }); -%>\n  it('should handle default state', () => {\n<% if(options.ts) { -%>\n    expect(<%-options.singleEntityLowerCase-%>Reducer(initialStore, {} as any)).toEqual({ ...initialStore });\n<% } else { -%>\n    expect(<%-options.singleEntityLowerCase-%>Reducer(initialStore, {})).toEqual({ ...initialStore });\n<% } -%>\n  });\n});\n","api":"const fakeRequest = () => new Promise((resolve) => setTimeout(() => resolve([]), 1000));\n\nexport const <%-options.apiNameTitle-%> = {\n<% Object.keys(worker).forEach(elem => { -%>\n<% for (let item of worker[elem].element){ -%>\n<% if(item.apiFuncName) { -%>\n  <%-item.apiFuncName-%>() {\n    return fakeRequest;\n  },\n<% } -%>\n<% } -%>\n<% }); -%>\n}"}